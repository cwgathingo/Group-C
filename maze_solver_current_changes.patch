diff --git a/controllers/maze_solver/maze_solver.py b/controllers/maze_solver/maze_solver.py
index c6e82d5..6b2b059 100644
--- a/controllers/maze_solver/maze_solver.py
+++ b/controllers/maze_solver/maze_solver.py
@@ -10,7 +10,7 @@ from robots.epuck_facade import EPuckFacade
 pathIndex = 0
 pathList = [
     MotionAction.MOVE_FORWARD_ONE_CELL,
-    MotionAction.MOVE_FORWARD_ONE_CELL,
+    MotionAction.TURN_LEFT_90,
     MotionAction.MOVE_FORWARD_ONE_CELL,
 ]
 
@@ -304,8 +304,8 @@ def main() -> None:
     goalCell: Cell = (3, 0)
 
     # TODO: set these to match your actual world
-    cellSizeMeters = 0.1          # placeholder
-    mazeOriginWorld = (-0.15, 0.15)  # placeholder (x, y of cell (0, 0) centre)
+    cellSizeMeters = 0.15          # placeholder
+    mazeOriginWorld = (-0.225, 0.225)  # placeholder (x, y of cell (0, 0) centre)
 
     controller = MazeController(
         rows,
diff --git a/controllers/maze_solver/robots/__pycache__/epuck_facade.cpython-312.pyc b/controllers/maze_solver/robots/__pycache__/epuck_facade.cpython-312.pyc
index d10c8ca..4c02dec 100644
Binary files a/controllers/maze_solver/robots/__pycache__/epuck_facade.cpython-312.pyc and b/controllers/maze_solver/robots/__pycache__/epuck_facade.cpython-312.pyc differ
diff --git a/controllers/maze_solver/robots/__pycache__/robot_interface.cpython-312.pyc b/controllers/maze_solver/robots/__pycache__/robot_interface.cpython-312.pyc
index 3ad07fd..a6aeae0 100644
Binary files a/controllers/maze_solver/robots/__pycache__/robot_interface.cpython-312.pyc and b/controllers/maze_solver/robots/__pycache__/robot_interface.cpython-312.pyc differ
diff --git a/controllers/maze_solver/robots/epuck_facade.py b/controllers/maze_solver/robots/epuck_facade.py
index f809fbb..c40c1c3 100644
--- a/controllers/maze_solver/robots/epuck_facade.py
+++ b/controllers/maze_solver/robots/epuck_facade.py
@@ -1,7 +1,7 @@
 # controllers/maze_solver/robots/epuck_facade.py
 
 from typing import Tuple, Optional
-import math
+from math import atan2, cos, hypot, pi, isnan, sin
 
 from controller import Robot as WebotsRobot
 
@@ -18,6 +18,8 @@ from maze.maze import Cell, Direction  # if Pylance complains, you can switch to
 
 
 WHEEL_RADIUS = 0.02 # meters
+POSITION_TOLERANCE = 0.0005
+ANGLE_TOLERANCE = 0.02  # radians ≈ 1.7°
 
 """
 Convert a maze Direction into a world-frame orientation angle.
@@ -34,7 +36,6 @@ For example, if NORTH corresponds to +y in world coordinates and EAST to
 You should adjust this mapping to match your actual world axes.
 """
 def _directionToWorldTheta(direction: Direction) -> float:
-    pi = math.pi
     if direction == Direction.EAST:
         return 0.0
     if direction == Direction.NORTH:
@@ -101,6 +102,9 @@ class EPuckFacade(RobotFacade):
         self._leftMotor.setVelocity(0.0)
         self._rightMotor.setVelocity(0.0)
 
+        # set speed scalar
+        self._baseForwardSpeedFrac = 0.3
+
         # Query max speeds
         self._maxLeftSpeed = self._leftMotor.getMaxVelocity()
         self._maxRightSpeed = self._rightMotor.getMaxVelocity()
@@ -113,7 +117,6 @@ class EPuckFacade(RobotFacade):
 
         self._compass = robot.getDevice('compass')
         self._compass.enable(basicStepMs)
-        # self._encoders = ...
         self._gps = robot.getDevice('gps')
         self._gps.enable(basicStepMs)
 
@@ -132,6 +135,21 @@ class EPuckFacade(RobotFacade):
         self._lastActionResult: ActionResult = ActionResult.NONE
         self._targetPose = None
 
+        # --- GPS calibration ---
+        self._gpsOffset: Optional[Tuple[float, float]] = None
+        self._gpsOffsetSamples: list[Tuple[float, float]] = []
+        self._gpsCalibStepsRemaining: int = 10   # ~10 update cycles
+        self._calibratingGps: bool = True
+
+        # While calibrating, report as busy so planner doesn’t send actions
+        self._state = RobotState.EXECUTING_ACTION
+
+        # --- Turn tracking ---
+        self._turnTargetTheta: Optional[float] = None
+        self._targetDirection: Optional[Direction] = None
+        self._turnSpeed: float = 0.2 * self._maxSpeed  # base turn speed
+        self._turnSign: Optional[int] = None   # +1 = left turn, -1 = right turn
+
     # ------------------------------------------------------------------
     # Core update loop
     # ------------------------------------------------------------------
@@ -148,36 +166,52 @@ class EPuckFacade(RobotFacade):
     def update(self, timeStepSeconds: float) -> None:
         print("time: ", self._robot.getTime())
         print('_gpsOffset', self._gpsOffset)
-        # First, if we haven't calibrated GPS offset yet, try to do it.
-        if self._gpsOffset is None:
-            gpsValues = self._gps.getValues()
-            gpsX, gpsY, _ = gpsValues
-
-            if not math.isnan(gpsX) and not math.isnan(gpsY):
-                worldX, worldY, _theta = self._worldPose
-                # gps = world + offset  → offset = gps - world
-                offsetX = gpsX - worldX
-                offsetY = gpsY - worldY
-                self._gpsOffset = (offsetX, offsetY)
-                # Optional debug:
-                print("[EPuckFacade] Calibrated GPS offset:", self._gpsOffset)
-            # If still NaN, just skip; we’ll try again on the next update.
+
+        # --- One-time GPS offset calibration phase ---
+        if self._calibratingGps:
+            if self._gpsCalibStepsRemaining > 0:
+                gpsX, gpsY, _ = self._gps.getValues()
+                if not isnan(gpsX) and not isnan(gpsY):
+                    worldX, worldY, _theta = self._worldPose  # from _setWorldPose
+                    offsetX = gpsX - worldX
+                    offsetY = gpsY - worldY
+                    self._gpsOffsetSamples.append((offsetX, offsetY))
+                    print(
+                        f"[EPuckFacade] GPS offset sample "
+                        f"{len(self._gpsOffsetSamples)}: ({offsetX:.6f}, {offsetY:.6f})"
+                    )
+
+                self._gpsCalibStepsRemaining -= 1
+                return  # stay "busy" during calibration
+
+            # Done collecting samples → compute average offset
+            if self._gpsOffsetSamples:
+                n = len(self._gpsOffsetSamples)
+                avgX = sum(s[0] for s in self._gpsOffsetSamples) / n
+                avgY = sum(s[1] for s in self._gpsOffsetSamples) / n
+                self._gpsOffset = (avgX, avgY)
+                print("[EPuckFacade] Final GPS offset:", self._gpsOffset)
+
+            self._calibratingGps = False
+            self._gpsOffsetSamples.clear()
+            self._state = RobotState.IDLE   # now planner can start issuing actions
+
+            # fall through and do nothing else this cycle
+            return
 
         if self._state != RobotState.EXECUTING_ACTION:
             # Nothing to do; keep motors stopped.
             return
 
-        # At the moment we only support one action type.
         if self._currentAction == MotionAction.MOVE_FORWARD_ONE_CELL:
             self._updateForwardAction()
+        elif self._currentAction in (
+            MotionAction.TURN_LEFT_90,
+            MotionAction.TURN_RIGHT_90,
+        ):
+            self._updateTurnAction()
 
 
-        # TODO: implement control logic for the current action.
-        # Something like:
-        # - if self._currentAction == MotionAction.MOVE_FORWARD_ONE_CELL: ...
-        # - if finished: self._finishAction(ActionResult.SUCCESS)
-        pass
-
     # ------------------------------------------------------------------
     # Pose / orientation
     # ------------------------------------------------------------------
@@ -199,8 +233,11 @@ class EPuckFacade(RobotFacade):
     For now you can return a dummy value until compass is wired.
     """
     def getHeadingVector(self) -> Vec2:
-        # TODO: read compass and convert to (hx, hy) unit vector.
-        return (0.0, 1.0)
+        theta = self._getCompassTheta()
+        if theta is None:
+            # Fallback to internal belief
+            _, _, theta = self._worldPose
+        return (cos(theta), sin(theta))
 
     """
     Get the robot's current heading snapped to the nearest cardinal direction.
@@ -221,7 +258,11 @@ class EPuckFacade(RobotFacade):
             return None
 
         gpsX, gpsY, _ = self._gps.getValues()
-        if math.isnan(gpsX) or math.isnan(gpsY):
+
+        print(
+            f"[EPuckFacade] gpsX={gpsX} gpsY={gpsY}"
+        )
+        if isnan(gpsX) or isnan(gpsY):
             return None
 
         offsetX, offsetY = self._gpsOffset
@@ -246,58 +287,65 @@ class EPuckFacade(RobotFacade):
         self._currentAction = MotionAction.MOVE_FORWARD_ONE_CELL
         self._lastActionResult = ActionResult.NONE
 
-        # TODO:
-        print(self._gps.getValues())
-        print(self._worldPose)
-        # - compute target world pose based on currentCell + currentDirection
-        dx, dy = directionUnit[self._currentDirection]
-        print("x, dy = directionUnit[self._currentDirection]", dx, dy)
-        currentX, currentY, _theta = self._worldPose
-        targetX = currentX + dx * self._cellSize
-        targetY = currentY + dy * self._cellSize
-        targetTheta = self._worldPose[2]  # same heading
-        self._targetPose = (targetX, targetY, targetTheta)
+
+        # Compute the discrete target cell and its world centre.
+        targetCell = self._getForwardCell() # based on currentCell + direction
+        print("targetCell", targetCell)
+        targetX, targetY = self._cellToWorld(targetCell)
+        _, _, theta = self._worldPose
+        self._targetPose = (targetX, targetY, theta)
+        self._targetCell = targetCell
+
         print("self._targetPose", self._targetPose)
         # - start motors in the right direction
-        forwardSpeed = 0.8 * self._maxSpeed
-        self._leftMotor.setVelocity(forwardSpeed)
-        self._rightMotor.setVelocity(forwardSpeed)
+        # Compute base forward speed once for this action
+        self._baseForwardSpeed = self._baseForwardSpeedFrac * self._maxSpeed
+        self._leftMotor.setVelocity(self._baseForwardSpeed)
+        self._rightMotor.setVelocity(self._baseForwardSpeed)
 
     """
     Request: turn 90 degrees left (counter-clockwise).
     """
     def requestTurnLeft90(self) -> None:
-        if self._state == RobotState.EXECUTING_ACTION:
-            return
-
-        self._state = RobotState.EXECUTING_ACTION
-        self._currentAction = MotionAction.TURN_LEFT_90
-        self._lastActionResult = ActionResult.NONE
-
-        # TODO:
-        # - determine target heading angle
-        # - start motors for in-place turn
-        pass
+        self._requestTurn90(MotionAction.TURN_LEFT_90)
 
     """
     Request: turn 90 degrees right (clockwise).
     """
     def requestTurnRight90(self) -> None:
+        self._requestTurn90(MotionAction.TURN_RIGHT_90)
+    
+
+    def _requestTurn90(self, action: MotionAction) -> None:
         if self._state == RobotState.EXECUTING_ACTION:
             return
 
         self._state = RobotState.EXECUTING_ACTION
-        self._currentAction = MotionAction.TURN_RIGHT_90
+        self._currentAction = action
         self._lastActionResult = ActionResult.NONE
 
-        # TODO: similar to requestTurnLeft90 but opposite direction.
-        pass
+        # +1 for left, -1 for right
+        self._turnSign = 1 if action == MotionAction.TURN_LEFT_90 else -1
+
+        # Compute target theta = dirTheta ± π/2
+        dTheta = self._turnSign * (0.5 * pi)
+        dirTheta = _directionToWorldTheta(self._currentDirection)
+        self._turnTargetTheta = self._wrapAngle(dirTheta + dTheta)
+
+        # Apply motor speeds using sign
+        leftSpeed  = -self._turnSign * self._turnSpeed
+        rightSpeed =  self._turnSign * self._turnSpeed
+
+        self._leftMotor.setVelocity(leftSpeed)
+        self._rightMotor.setVelocity(rightSpeed)
+
 
     """
     Update logic for MOVE_FORWARD_ONE_CELL.
 
-    Uses GPS (with offset) to estimate current (x, y), compares to
-    target cell centre, and stops when within a small threshold.
+    Uses GPS (with offset) to estimate current (x, y), applies a small
+    lateral steering correction to stay close to the ideal line, and
+    stops when the target cell centre is reached or slightly overshot.
     """
     def _updateForwardAction(self) -> None:
         cleanPos = self._getCleanWorldXY()
@@ -309,45 +357,108 @@ class EPuckFacade(RobotFacade):
         currentX, currentY = cleanPos
         targetX, targetY, targetTheta = self._targetPose
 
-        # Update our internal world pose's x,y; keep theta as before for now.
+        # Update internal world pose x,y; keep theta as before for now.
         _oldX, _oldY, currentTheta = self._worldPose
         self._worldPose = (currentX, currentY, currentTheta)
 
-        # Distance to target centre
-        dist = math.hypot(targetX - currentX, targetY - currentY)
-        # Tune this threshold; 0.005 = 5mm, 0.01 = 1cm, etc.
-        positionTolerance = 0.001
-
-        # Debug (optional)
-        print(f"[EPuckFacade] forward dist={dist:.4f}, target=({targetX:.3f},{targetY:.3f}), "
-              f"pos=({currentX:.3f},{currentY:.3f})")
-
-        if dist > positionTolerance:
-            # Not there yet; leave motors running.
+        # steering correction based on lateral error
+        # Edit: It's too soft. Trying to do heading now.
+        # lateralErr = self._computeLateralError(currentX, currentY)
+
+        # ---------- HEADING-BASED STEERING + DEBUG ----------
+        # Vector from current position to target.
+        # EDIT: This also doesn't work. Dropping for now.
+        # vx = targetX - currentX
+        # vy = targetY - currentY
+        # dist = hypot(vx, vy)
+
+        # if dist > 1e-6:
+        #     tx = vx / dist
+        #     ty = vy / dist
+        # else:
+        #     # Already at target; steering not needed.
+        #     tx, ty = 0.0, 0.0
+
+        # # Desired forward direction from maze heading.
+        # fx, fy = directionUnit[self._currentDirection]
+
+        # # Signed heading error ~ sin(angle) between forward and target-dir.
+        # # >0 → target lies to the LEFT of our forward axis.
+        # # <0 → target lies to the RIGHT.
+        # headingErr = fx * ty - fy * tx
+        # self._applyHeadingCorrection(headingErr)
+        # print(
+        #     f"[FWD] cell={self._currentCell} dir={self._currentDirection.name} "
+        #     f"pos=({currentX:.3f},{currentY:.3f}) target=({targetX:.3f},{targetY:.3f}) "
+        #     f"v=({vx:.3f},{vy:.3f}) dist={dist:.4f} "
+        #     f"t=({tx:.2f},{ty:.2f}) f=({fx:.2f},{fy:.2f}) "
+        #     f"headingErr={headingErr:.4f} "
+        # )
+        
+        # --- Existing target check / overshoot handling ---
+        if not self._isAtTarget():
+            # Not there yet; leave motors running (with corrected speeds).
             return
 
-        # We consider the movement complete. Stop motors and finish.
+        # Movement complete: stop motors and finish.
         self._leftMotor.setVelocity(0.0)
         self._rightMotor.setVelocity(0.0)
 
         # Update discrete cell belief: we have moved one cell in currentDirection.
-        row, col = self._currentCell
-        if self._currentDirection == Direction.NORTH:
-            row -= 1
-        elif self._currentDirection == Direction.SOUTH:
-            row += 1
-        elif self._currentDirection == Direction.EAST:
-            col += 1
-        elif self._currentDirection == Direction.WEST:
-            col -= 1
-        self._currentCell = (row, col)
-
-        # Snap worldPose to the exact target (optional but nice).
+        self._currentCell = self._targetCell
+
+        # Snap worldPose to the exact target.
         self._worldPose = (targetX, targetY, targetTheta)
 
         self._finishAction(ActionResult.SUCCESS)
         print("Finished Action Forward")
 
+    """
+    Update logic for 90° turn actions (left or right).
+
+    Uses the compass to estimate current heading, compares to the
+    desired cardinal heading, and stops when we are within a small
+    angular tolerance.
+    """
+    def _updateTurnAction(self) -> None:
+        if self._turnTargetTheta is None or self._turnSign is None:
+            return
+
+        theta = self._getCompassTheta()
+        if theta is None:
+            # No reliable compass yet; keep turning.
+            return
+
+        x, y, _oldTheta = self._worldPose
+        self._worldPose = (x, y, theta)
+
+        # Signed angular difference current → target in [-π, π]
+        deltaTheta = self._wrapAngle(self._turnTargetTheta - theta)
+
+        print(
+            f"[EPuckFacade] turn action={self._currentAction.name} "
+            f"theta={theta:.3f} target={self._turnTargetTheta:.3f} "
+            f"deltaTheta={deltaTheta:.4f}"
+        )
+
+        if abs(deltaTheta) <= ANGLE_TOLERANCE:
+            # Stop motors
+            self._leftMotor.setVelocity(0.0)
+            self._rightMotor.setVelocity(0.0)
+
+            # Rotate discrete heading by the same sign as the turn
+            order = [Direction.EAST, Direction.NORTH, Direction.WEST, Direction.SOUTH]
+            idx = order.index(self._currentDirection)
+            idx = (idx + self._turnSign) % 4
+            self._currentDirection = order[idx]
+
+            self._turnTargetTheta = None
+            self._turnSign = None
+
+            self._finishAction(ActionResult.SUCCESS)
+            print("[EPuckFacade] Finished 90° turn")
+            return
+        
     # ------------------------------------------------------------------
     # Status / results
     # ------------------------------------------------------------------
@@ -423,16 +534,16 @@ class EPuckFacade(RobotFacade):
     # ------------------------------------------------------------------
 
     def _setWorldPose(self) -> None:
-                # --- Continuous pose (world coordinates) ---
+        # --- Continuous pose (world coordinates) ---
         # Start exactly at the centre of the start cell.
         (row, col) = self._currentCell
         (originX, originY) = self._mazeOrigin
 
-        worldX = originX + row * self._cellSize
-        worldY = originY - col * self._cellSize
+        worldX = originX + col * self._cellSize
+        worldY = originY - row * self._cellSize
         theta = _directionToWorldTheta(self._currentDirection)
 
-        self._worldPose: Pose2D = (worldX, worldY, theta)
+        self._worldPose = (worldX, worldY, theta)
 
     """
     Optionally return the robot's precise world pose.
@@ -456,7 +567,7 @@ class EPuckFacade(RobotFacade):
         return (x, y)
 
     # ------------------------------------------------------------------
-    # Internal helpers (you’ll implement these as you go)
+    # Internal helpers
     # ------------------------------------------------------------------
 
     """
@@ -472,3 +583,313 @@ class EPuckFacade(RobotFacade):
         self._lastActionResult = result
         self._state = RobotState.IDLE
         self._currentAction = None
+
+    """
+    Get the maze cell one step ahead of the current cell.
+
+    This helper uses the robot's current discrete pose
+    (self._currentCell and self._currentDirection) to compute
+    the neighbour cell in front of the robot:
+
+    - NORTH: (row - 1, col)
+    - SOUTH: (row + 1, col)
+    - EAST:  (row, col + 1)
+    - WEST:  (row, col - 1)
+
+    It does not perform any bounds checking; callers are responsible
+    for ensuring that the returned cell is inside the maze.
+
+    @return Cell one step forward as (row, col).
+    """
+    def _getForwardCell(self) -> Cell:
+        r, c = self._currentCell
+        dir = self._currentDirection
+        if dir == Direction.NORTH:
+            r -= 1
+        elif dir == Direction.SOUTH:
+            r += 1
+        elif dir == Direction.EAST:
+            c += 1
+        else:
+            c -= 1
+        return (r, c)
+    
+    """
+    Convert a maze cell (row, col) to the world coordinates of its centre.
+
+    The mapping assumes:
+    - self._mazeOrigin = (originX, originY) is the centre of cell (0, 0).
+    - Columns increase to the right → +X direction.
+    - Rows increase downward in the maze → -Y direction.
+
+    Therefore:
+        x = originX + col * cellSize
+        y = originY - row * cellSize
+
+    @param cell Maze cell as (row, col).
+    @return World position (x, y) of the cell centre.
+    """
+    def _cellToWorld(self, cell: Cell) -> Vec2:
+        xWorld = self._mazeOrigin[0] + cell[1] * self._cellSize
+        yWorld = self._mazeOrigin[1] - cell[0] * self._cellSize
+        return (xWorld, yWorld)
+    
+
+    """
+    Check whether the robot has reached (or passed) the current target.
+
+    Uses two criteria:
+
+    1) Distance to target centre is within POSITION_TOLERANCE.
+    2) Overshoot detection: if the target is *behind* the robot along the
+       forward direction (dot product < 0), we consider the move complete
+       even if distance is still > tolerance.
+
+       This prevents forward motion from continuing forever after passing
+       the target due to momentum, overshoot, or control inaccuracy.
+
+    Current position is extracted from GPS and corrected by our offset.
+    If GPS is not yet valid, returns False.
+    """
+    def _isAtTarget(self) -> bool:
+        global POSITION_TOLERANCE
+
+        global POSITION_TOLERANCE
+
+        cleanPos = self._getCleanWorldXY()
+        if cleanPos is None:
+            return False
+
+        currentX, currentY = cleanPos
+        targetX, targetY, _ = self._targetPose
+
+        # Vector from current → target
+        vx = targetX - currentX
+        vy = targetY - currentY
+
+        # Distance
+        dist = hypot(vx, vy)
+
+        # Forward unit vector (from your directionUnit mapping)
+        fx, fy = directionUnit[self._currentDirection]
+
+        # Dot product determines overshoot
+        dot = vx * fx + vy * fy
+
+        # --- Debug output ---
+        print(
+            f"[EPuckFacade] isAtTarget? "
+            f"dist={dist:.4f} "
+            f"dot={dot:.4f} "
+            f"pos=({currentX:.3f},{currentY:.3f}) "
+            f"target=({targetX:.3f},{targetY:.3f}) "
+            f"forward=({fx:.2f},{fy:.2f})"
+        )
+
+        # Condition 1: within distance tolerance
+        if dist <= POSITION_TOLERANCE:
+            return True
+
+        # Condition 2: overshoot → target behind robot
+        if dot < 0.0:
+            return True
+
+        return False
+    
+    """
+    Compute signed lateral error from the ideal straight path between
+    the start cell and the target cell for this forward move.
+
+    The ideal path is the line through the centre of currentCell in the
+    current maze heading direction. Positive error means the robot is
+    displaced to one side of that line, negative to the other.
+
+    @param currentX Current world X position (corrected GPS).
+    @param currentY Current world Y position (corrected GPS).
+    @return Lateral error in meters.
+    """
+    def _computeLateralError(self, currentX: float, currentY: float) -> float:
+        # Ideal start point = centre of the current cell.
+        startX, startY = self._cellToWorld(self._currentCell)
+
+        # Displacement from start of this move.
+        dx = currentX - startX
+        dy = currentY - startY
+
+        # Forward unit vector (maze heading, using your global map)
+        fx, fy = directionUnit[self._currentDirection]
+
+        # Perpendicular to forward (left-hand normal)
+        # If forward = (fx, fy), one normal is n = (-fy, fx)
+        nx = -fy
+        ny = fx
+
+        # Signed distance from ideal line
+        lateralErr = dx * nx + dy * ny
+
+        # DEBUG (optional)
+        # Comment out when stable
+        print(
+            f"[EPuckFacade] lateralErr={lateralErr:.4f}m "
+            f"pos=({currentX:.3f},{currentY:.3f}) "
+            f"start=({startX:.3f},{startY:.3f}) "
+            f"dxdy=({dx:.3f},{dy:.3f}) "
+            f"forward=({fx:.2f},{fy:.2f}) "
+            f"normal=({nx:.2f},{ny:.2f})"
+        )
+
+        # Signed lateral error: projection onto the normal
+        return lateralErr
+    
+    """
+    Apply a proportional steering correction based on lateral error.
+
+    lateralErr is the signed distance from the ideal straight-line path:
+    - lateralErr > 0 → robot is to the LEFT of the ideal line.
+    - lateralErr < 0 → robot is to the RIGHT of the ideal line.
+
+    We adjust left/right wheel speeds symmetrically around a base
+    forward speed so that the robot steers back toward the path:
+
+        left  = base + K * lateralErr
+        right = base - K * lateralErr
+
+    This means:
+    - If lateralErr > 0 (too far left), the left wheel is faster than
+      the right, causing a rightward turn back toward the path.
+    - If lateralErr < 0 (too far right), the right wheel is faster than
+      the left, causing a leftward turn.
+
+    Speeds are clamped to the motor's max velocity.
+    """
+    def _applyLateralCorrection(self, lateralErr: float) -> None:
+        base = self._baseForwardSpeed
+        K = 50  # tune
+
+        # If lateralErr > 0 we are "left" of the line.
+        # To steer back, the LEFT wheel should be faster than the RIGHT.
+        correction = K * lateralErr
+
+        leftSpeed  = base - correction
+        rightSpeed = base + correction
+
+        # Clamp to motor limits
+        leftSpeed = max(-self._maxSpeed, min(self._maxSpeed, leftSpeed))
+        rightSpeed = max(-self._maxSpeed, min(self._maxSpeed, rightSpeed))
+
+        self._leftMotor.setVelocity(leftSpeed)
+        self._rightMotor.setVelocity(rightSpeed)
+
+        print(
+            f"[EPuckFacade] lateralErr={lateralErr:.4f} "
+            f"base={base:.3f} left={leftSpeed:.3f} right={rightSpeed:.3f}"
+        )
+
+    """
+    Apply a proportional steering correction based on heading error.
+
+    headingErr is approximately sin(dTheta) between the robot's forward
+    direction (maze heading) and the unit vector from current position
+    to the target cell centre:
+
+        headingErr > 0 → target lies to the LEFT of the forward axis.
+        headingErr < 0 → target lies to the RIGHT.
+
+    We steer back toward the target by asymmetrically adjusting speeds
+    around a base forward speed:
+
+        left  = base - K * headingErr
+        right = base + K * headingErr
+
+    This means:
+    - If headingErr > 0 (target left), right wheel is faster → turn left.
+    - If headingErr < 0 (target right), left wheel is faster → turn right.
+
+    Returns the (leftSpeed, rightSpeed) actually commanded.
+    """
+    def _applyHeadingCorrection(self, headingErr: float) -> Tuple[float, float]:
+        base = self._baseForwardSpeed  # set when the action starts
+
+        # Start with a much stronger gain; tune down from here if it oscillates.
+        K = 10.0 * self._maxSpeed
+
+        correction = K * headingErr
+
+        leftSpeed = base - correction
+        rightSpeed = base + correction
+
+        print(
+            f"[EPuckFacade] correction={correction:.4f} base={base:.3f} "
+            f"left={leftSpeed:.3f} right={rightSpeed:.3f}"
+        )
+
+
+        # Clamp to motor limits.
+        if leftSpeed > self._maxSpeed:
+            leftSpeed = self._maxSpeed
+        if leftSpeed < -self._maxSpeed:
+            leftSpeed = -self._maxSpeed
+
+        if rightSpeed > self._maxSpeed:
+            rightSpeed = self._maxSpeed
+        if rightSpeed < -self._maxSpeed:
+            rightSpeed = -self._maxSpeed
+
+        self._leftMotor.setVelocity(leftSpeed)
+        self._rightMotor.setVelocity(rightSpeed)
+
+        print(
+            f"[EPuckFacade] headingErr={headingErr:.4f} base={base:.3f} "
+            f"left={leftSpeed:.3f} right={rightSpeed:.3f}"
+        )
+
+        return leftSpeed, rightSpeed
+    
+    """
+    Read the compass and convert to a world-frame heading angle theta.
+
+    Convention matches _directionToWorldTheta:
+        EAST  → 0 rad
+        NORTH → +π/2
+        WEST  → π
+        SOUTH → -π/2
+    """
+    def _getCompassTheta(self) -> Optional[float]:
+        if self._compass is None:
+            return None
+
+        vals = self._compass.getValues()
+        cx, _cy, cz = vals
+
+        if isnan(cx) or isnan(cz):
+            return None
+
+        # Webots compass gives NORTH direction in robot frame as (x,z)
+        # yaw_c = atan2(x, z), 0 when facing NORTH, +π/2 when facing EAST, etc.
+        yaw_c = atan2(cx, cz)
+
+        # Convert to our convention: EAST=0, NORTH=+π/2, WEST=π, SOUTH=-π/2
+        theta = (0.5 * pi) - yaw_c
+
+        # Wrap to [-π, π]
+        if theta > pi:
+            theta -= 2.0 * pi
+        if theta < -pi:
+            theta += 2.0 * pi
+
+        return theta
+    
+    """
+    Smallest signed angle from current → target, in [-π, π].
+    """
+    def _angleDiff(self, target: float, current: float) -> float:
+        diff = target - current
+        while diff > pi:
+            diff -= 2.0 * pi
+        while diff < -pi:
+            diff += 2.0 * pi
+        return diff
+    
+    """Wrap angle to [-π, π]."""
+    def _wrapAngle(self, theta: float) -> float:
+        return (theta + pi) % (2.0 * pi) - pi
\ No newline at end of file
diff --git a/worlds/.CSCK505_robot_solve_maze.jpg b/worlds/.CSCK505_robot_solve_maze.jpg
index d5fe16c..51f95c5 100644
Binary files a/worlds/.CSCK505_robot_solve_maze.jpg and b/worlds/.CSCK505_robot_solve_maze.jpg differ
diff --git a/worlds/.CSCK505_robot_solve_maze.wbproj b/worlds/.CSCK505_robot_solve_maze.wbproj
index 5537ac8..8d06f4c 100644
--- a/worlds/.CSCK505_robot_solve_maze.wbproj
+++ b/worlds/.CSCK505_robot_solve_maze.wbproj
@@ -1,11 +1,12 @@
 Webots Project File version R2025a
-perspectives: 000000ff00000000fd00000002000000010000056300000514fc0200000001fb0000001400540065007800740045006400690074006f0072010000001d000005140000004400ffffff0000000300000f00000002b6fc0100000001fb0000001a0043006f006e0073006f006c00650041006c006c0041006c006c010000000000000f000000006900ffffff0000099b0000051400000001000000020000000100000008fc00000000
+perspectives: 000000ff00000000fd00000002000000010000056300000514fc0200000001fb0000001400540065007800740045006400690074006f0072010000001d000005140000009200ffffff0000000300000f00000002b6fc0100000001fb0000001a0043006f006e0073006f006c00650041006c006c0041006c006c010000000000000f000000006900ffffff0000099b0000051400000001000000020000000100000008fc00000000
 simulationViewPerspectives: 000000ff00000001000000020000043c000009a40100000002010000000100
 sceneTreePerspectives: 000000ff000000010000000300000026000000c0000000fa0100000002010000000200
 maximizedDockId: -1
 centralWidgetVisible: 1
-orthographicViewHeight: 1
-textFiles: -1
+projectionMode: ORTHOGRAPHIC
+orthographicViewHeight: 0.829355
+textFiles: 1 "controllers/maze_solver/maze_solver.py" "../CSCK505_robot_solve_maze/controllers/e-puck-maze/e-puck-maze.py"
 globalOptionalRendering: DistanceSensorRays
 consoles: Console:All:All
 renderingDevicePerspectives: e-puck-maze:camera;1;1;0;0
diff --git a/worlds/CSCK505_robot_solve_maze.wbt b/worlds/CSCK505_robot_solve_maze.wbt
index 60d21ff..7db90b0 100644
--- a/worlds/CSCK505_robot_solve_maze.wbt
+++ b/worlds/CSCK505_robot_solve_maze.wbt
@@ -5,19 +5,17 @@ EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/project
 EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/objects/floors/protos/RectangleArena.proto"
 EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/robots/gctronic/e-puck/protos/E-puck.proto"
 EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/objects/apartment_structure/protos/Wall.proto"
-EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/objects/floors/protos/Floor.proto"
-EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/appearances/protos/Parquetry.proto"
 
 WorldInfo {
 }
 Viewpoint {
   orientation -0.593029167020117 0.5917464092945832 0.5460335100984128 2.1397846515477195
-  position 0.006691077471925639 0.03791465622714529 0.7534607367531094
+  position 0.00656785603317819 0.04204964551320814 0.8049893449406769
 }
 TexturedBackground {
 }
 E-puck {
-  translation 0.15 -0.15 0
+  translation 0.225 -0.225 0
   rotation 0 0 1 1.5707996938995747
   name "e-puck-maze"
   controller "maze_solver"
@@ -32,60 +30,41 @@ E-puck {
 TexturedBackgroundLight {
 }
 RectangleArena {
-  floorSize 0.4 0.4
-  floorTileSize 0.2 0.2
+  floorSize 0.6 0.6
+  floorTileSize 0.3 0.3
   wallHeight 0.05
 }
 Wall {
-  translation -0.1 -0.05 0
+  translation -0.147677 0.0059285 0
   size 0.01 0.3 0.1
 }
 Wall {
-  translation 0.1 -0.155 0
+  translation 0.150451 -0.229374 0
   name "wall(1)"
   size 0.01 0.115 0.1
 }
 Wall {
-  translation 0.1 0.05 0
+  translation 0.148586 0.0693601 0
   name "wall(3)"
   size 0.01 0.1 0.1
 }
 Wall {
-  translation 0 -0.05 0
+  translation 0.000622046 -0.0687469 0
   name "wall(2)"
   size 0.01 0.1 0.1
 }
 Wall {
-  translation 0 0.15 0
+  translation 0.00268851 0.201874 0
   name "wall(4)"
   size 0.01 0.1 0.1
 }
 Wall {
-  translation 0.05 -0.1 0
+  translation 0.0767822 -0.145623 0
   name "wall(5)"
   size 0.1 0.01 0.1
 }
 Wall {
-  translation 0.05 0.1 0
+  translation 0.0718036 0.154985 0
   name "wall(6)"
   size 0.1 0.01 0.1
 }
-Floor {
-  translation 0.15 -0.15 0
-  size 0.08 0.08
-  tileSize 0.05 0.05
-  appearance Parquetry {
-    type "chequered"
-    colorOverride 1 0 0.0156863
-  }
-}
-Floor {
-  translation -0.15 -0.15 0
-  name "floor(1)"
-  size 0.08 0.08
-  tileSize 0.05 0.05
-  appearance Parquetry {
-    type "chequered"
-    colorOverride 0 1 0.0823529
-  }
-}
